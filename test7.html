<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pointillist Radial Gradient POC</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #fff; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <script>
    const vsSource = `#version 300 es
    in vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }`;

    const fsSource = `#version 300 es
    precision highp float;
    uniform vec2 u_resolution;
    uniform vec2 u_center;
    uniform float u_sigma;
    out vec4 fragColor;

    // simple hash-based random in [0,1)
    float rand(vec2 co){
      return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
      // map gl_FragCoord to [0..res]
      vec2 uv = gl_FragCoord.xy;
      float r = distance(uv, u_center);
      // Gaussian falloff
      float p = exp(- (r * r) / (2.0 * u_sigma * u_sigma));
      // scatter test
      if (rand(uv) < p) {
        fragColor = vec4(1.0, 0.0, 0.5, 1.0); // bright pink
      } else {
        fragColor = vec4(1.0);               // white
      }
    }`;

    // compile helper
    function compileShader(gl, type, source) {
      const s = gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        gl.deleteShader(s);
        return null;
      }
      return s;
    }

    function init() {
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl2');
      if (!gl) { alert('WebGL2 required'); return; }

      // full-screen quad
      const posBuf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,   1, -1,   -1, 1,
        -1,  1,   1, -1,    1, 1
      ]), gl.STATIC_DRAW);

      // compile shaders & link
      const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return;
      }
      gl.useProgram(prog);

      // set up attributes
      const posLoc = gl.getAttribLocation(prog, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      // uniforms
      const resLoc   = gl.getUniformLocation(prog, 'u_resolution');
      const cenLoc   = gl.getUniformLocation(prog, 'u_center');
      const sigLoc   = gl.getUniformLocation(prog, 'u_sigma');

      // resize & draw
      function draw() {
        canvas.width  = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        gl.uniform2f(resLoc, canvas.width, canvas.height);
        gl.uniform2f(cenLoc, canvas.width / 2, canvas.height / 2);
        gl.uniform1f(sigLoc, Math.min(canvas.width, canvas.height) * 0.25);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      window.addEventListener('resize', draw);
      draw();
    }

    window.onload = init;
  </script>
</body>
</html>
