<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Radial Gradient w/ Noise Texture</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#fff; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <script>
    // Vertex shader (full-screen quad)
    const vsSource = `#version 300 es
    in vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }`;

    // Fragment shader samples a noise texture instead of fract(sin)
    const fsSource = `#version 300 es
    precision highp float;
    uniform vec2 u_resolution;
    uniform vec2 u_center;
    uniform float u_sigma;
    uniform sampler2D u_noise;
    out vec4 fragColor;

    void main() {
      vec2 uv = gl_FragCoord.xy;
      float r = distance(uv, u_center);
      // Gaussian fall-off
      float p = exp(- (r * r) / (2.0 * u_sigma * u_sigma));

      // Map screen coord into noise-space (tile every 512px)
      vec2 noiseUV = uv / 512.0;
      float n = texture(u_noise, noiseUV).r;

      if (n < p) {
        fragColor = vec4(1.0, 0.0, 0.5, 1.0); // bright pink
      } else {
        fragColor = vec4(1.0);               // white
      }
    }`;

    function compileShader(gl, type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
      }
      return s;
    }

    function init() {
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl2');
      if (!gl) { alert('WebGL2 required'); return; }

      // full-screen quad setup
      const quad = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1,  1,-1,  -1,1,
         1, 1,  -1,1,   1,-1
      ]), gl.STATIC_DRAW);

      // compile & link
      const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return;
      }
      gl.useProgram(prog);

      // bind quad to a_position
      const posLoc = gl.getAttribLocation(prog, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      // uniforms
      const uRes    = gl.getUniformLocation(prog, 'u_resolution');
      const uCtr    = gl.getUniformLocation(prog, 'u_center');
      const uSig    = gl.getUniformLocation(prog, 'u_sigma');
      const uNoise  = gl.getUniformLocation(prog, 'u_noise');

      // load noise texture
      const noiseTex = gl.createTexture();
      const img = new Image();
      img.src = 'bn_4.png';
      img.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, noiseTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, gl.RED, gl.UNSIGNED_BYTE, img);
        // allow tiling
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        // nearest avoids filtering artifacts
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        // bind texture unit 0 â†’ u_noise
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uNoise, 0);

        draw();
      };

      function draw() {
        canvas.width  = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform2f(uCtr, canvas.width/2, canvas.height/2);
        gl.uniform1f(uSig, Math.min(canvas.width, canvas.height) * 0.25);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      window.addEventListener('resize', draw);
    }

    window.onload = init;
  </script>
</body>
</html>
