<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Two-Gradient on White, 3× Point Size</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#fff; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <script>
    const vsSource = `#version 300 es
    in vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }`;

    const fsSource = `#version 300 es
    precision highp float;

    uniform vec2 u_resolution;
    uniform vec2 u_center1;
    uniform vec2 u_center2;
    uniform float u_sigma;
    uniform sampler2D u_noise;
    out vec4 fragColor;

    // dot spacing = 3px
    const float POINT_SIZE = 2.0;
    const float NOISE_TILE = 512.0;

    void main() {
      vec2 uv = gl_FragCoord.xy;

      // gradient probabilities
      float r1 = distance(uv, u_center1);
      float p1 = exp(-r1*r1/(2.0*u_sigma*u_sigma));
      float r2 = distance(uv, u_center2);
      float p2 = exp(-r2*r2/(2.0*u_sigma*u_sigma));

      // group into 3×3 cells so each dot is 3px square
      vec2 cell = floor(uv/POINT_SIZE)*POINT_SIZE + POINT_SIZE*0.5;
      float n = texture(u_noise, cell/NOISE_TILE).r;

      // colors in RGB
      vec3 pink   = vec3(1.0, 0.31, 0.91);
      vec3 yellow = vec3(1.0, 1.0, 0.0);

      // start on white, multiply through any dots
      vec3 col = vec3(1.0);
      if (n < p1) col *= pink;
      if (n < p2) col *= yellow;

      fragColor = vec4(col, 1.0);
    }`;

    function compileShader(gl, type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        gl.deleteShader(s);
        return null;
      }
      return s;
    }

    function init() {
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl2');
      if (!gl) { alert('WebGL2 required'); return; }

      // full-screen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1,   1,-1,   -1,1,
         1, 1,  -1, 1,    1,-1
      ]), gl.STATIC_DRAW);

      // compile & link
      const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return;
      }
      gl.useProgram(prog);

      // attributes
      const posLoc = gl.getAttribLocation(prog, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      // uniforms
      const uRes   = gl.getUniformLocation(prog, 'u_resolution');
      const uC1    = gl.getUniformLocation(prog, 'u_center1');
      const uC2    = gl.getUniformLocation(prog, 'u_center2');
      const uSig   = gl.getUniformLocation(prog, 'u_sigma');
      const uNoise = gl.getUniformLocation(prog, 'u_noise');

      // load noise
      const noiseTex = gl.createTexture();
      const img = new Image();
      img.src = 'bn_4.png';
      img.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, noiseTex);
        gl.texImage2D(
          gl.TEXTURE_2D, 0,
          gl.R8,    // sized internal format
          gl.RED,   // base format
          gl.UNSIGNED_BYTE,
          img
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uNoise, 0);

        draw();
        window.addEventListener('resize', draw);
      };

      function draw() {
        canvas.width  = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform2f(uC1, canvas.width*0.33, canvas.height*0.5);
        gl.uniform2f(uC2, canvas.width*0.66, canvas.height*0.5);
        gl.uniform1f(uSig, Math.min(canvas.width, canvas.height)*0.25);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    }

    window.onload = init;
  </script>
</body>
</html>
