<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Two-Gradient on White, 3× Point Size</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#fff; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <script>
    const vsSource = `#version 300 es
    in vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }`;

    const fsSource = `#version 300 es
    precision highp float;

    uniform vec2 u_resolution;
    uniform vec2 u_center1;
    uniform vec2 u_center2;
    uniform float u_sigma;
    uniform sampler2D u_noise1;
    uniform sampler2D u_noise2;
    out vec4 fragColor;

    // dot spacing = 3px
    const float POINT_SIZE = 2.0;
    const float NOISE_TILE = 512.0;

    void main() {
      vec2 uv = gl_FragCoord.xy;

      // Gaussian fall‐off parameters
      float r1 = distance(uv, u_center1);
      float p1 = exp(-r1*r1 / (2.0 * u_sigma * u_sigma));
      float r2 = distance(uv, u_center2);
      float p2 = exp(-r2*r2 / (2.0 * u_sigma * u_sigma));

      // group into 3×3 cells and sample noise at the cell‐center
      vec2 cell = floor(uv/POINT_SIZE) * POINT_SIZE + POINT_SIZE*0.5;
      vec2 noiseUV = cell / NOISE_TILE;

      // two independent noise samples for the pink gradient
      float nP1 = texture(u_noise1, noiseUV).r;
      float nP2 = texture(u_noise2, noiseUV).r;

      // base colours
      vec3 pink   = vec3(0.980, 0.420, 1.0);
      vec3 yellow = vec3(1.0, 1.0, 0.0);

      // start from white
      vec3 col = vec3(1.0);

      // each if is one layer; stacking two gives deeper saturation
      if (nP1 < p1) col *= pink;
      if (nP2 < p1) col *= pink;

      if (nP1 < p2) col *= yellow;
      if (nP2 < p2) col *= yellow;

      fragColor = vec4(col, 1.0);
    }`;


    function compileShader(gl, type, src) {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(s));
            gl.deleteShader(s);
            return null;
          }
          return s;
        }

    function loadTextureAsync(gl, src, unit) {
      return new Promise((resolve) => {
        const tex = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0 + unit);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        // placeholder pixel
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, 1, 1, 0, gl.RED, gl.UNSIGNED_BYTE, new Uint8Array([128]));

        const img = new Image();
        img.src = src;
        img.onload = () => {
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, tex);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, gl.RED, gl.UNSIGNED_BYTE, img);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          resolve();    // signal that this texture is ready
        };
      });
    }

    async function init() {
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl2');
      if (!gl) { alert('WebGL2 required'); return; }

      // full-screen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1,   1,-1,   -1,1,
         1, 1,  -1, 1,    1,-1
      ]), gl.STATIC_DRAW);

      // compile & link
      const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return;
      }
      gl.useProgram(prog);

      // attributes
      const posLoc = gl.getAttribLocation(prog, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      // uniforms
      const uRes   = gl.getUniformLocation(prog, 'u_resolution');
      const uC1    = gl.getUniformLocation(prog, 'u_center1');
      const uC2    = gl.getUniformLocation(prog, 'u_center2');
      const uSig   = gl.getUniformLocation(prog, 'u_sigma');
      const uNoise1 = gl.getUniformLocation(prog, 'u_noise1');
      const uNoise2 = gl.getUniformLocation(prog, 'u_noise2');

      // load noise
      await Promise.all([
        loadTextureAsync(gl, 'bn_4.png', 0),
        loadTextureAsync(gl, 'bn_5.png', 1)
      ])

      gl.useProgram(prog)
      gl.uniform1i(uNoise1, 0);
      gl.uniform1i(uNoise2, 1);

      draw();
      window.addEventListener('resize', draw);
      

      function draw() {
        canvas.width  = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform2f(uC1, canvas.width*0.33, canvas.height*0.5);
        gl.uniform2f(uC2, canvas.width*0.66, canvas.height*0.5);
        gl.uniform1f(uSig, Math.min(canvas.width, canvas.height)*0.25);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    }

    window.onload = init;
  </script>
</body>
</html>
